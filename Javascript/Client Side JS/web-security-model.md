# ওয়েব সিকিউরিটি মডেল: জাভাস্ক্রিপ্ট প্রোগ্রামারদের যা জানা জরুরি

ওয়েব পেজগুলো আমাদের ব্যক্তিগত ডিভাইসে (ব্রাউজারে) কোড রান করে। এটি একই সাথে শক্তিশালী এবং ঝুঁকিপূর্ণ। ব্রাউজার ভেন্ডরদের (যেমন Chrome, Firefox) তাই সব সময় দুটি বিপরীত লক্ষ্যের মধ্যে ভারসাম্য বজায় রাখতে হয়:

1. এমন শক্তিশালী API তৈরি করা যা দিয়ে দারুণ সব ওয়েব অ্যাপ্লিকেশন বানানো যায়।
2. ক্ষতিকর কোড যেন আপনার ডাটা চুরি, প্রাইভেসি নষ্ট বা কোনো স্ক্যাম করতে না পারে তা নিশ্চিত করা।

একজন জাভাস্ক্রিপ্ট ডেভেলপার হিসেবে আপনাকে ব্রাউজারের এই নিরাপত্তা ব্যবস্থাগুলো সম্পর্কে পরিষ্কার ধারণা রাখতে হবে। নিচে বিষয়গুলো বিস্তারিত আলোচনা করা হলো।

## ১. জাভাস্ক্রিপ্ট যা করতে পারে না (Limitations)

ব্রাউজারের সুরক্ষার প্রথম ধাপ হলো জাভাস্ক্রিপ্টকে কিছু কাজ করার ক্ষমতাই না দেওয়া। একে **Sandboxing** বলা যেতে পারে।

* **ফাইল সিস্টেমে প্রবেশ নিষেধ:** ক্লায়েন্ট-সাইড জাভাস্ক্রিপ্ট (যা ব্রাউজারে চলে) আপনার কম্পিউটারের ফাইল পড়তে, লিখতে বা ডিলেট করতে পারে না। এটি কোনো ভাইরাস ইনস্টল করতে বা আপনার হার্ড ড্রাইভের ডিরেক্টরি দেখতে পারে না।

* **সীমাবদ্ধ নেটওয়ার্কিং:** জাভাস্ক্রিপ্ট `HTTP` রিকোয়েস্ট (AJAX/Fetch) বা `WebSockets` ব্যবহার করে সার্ভারের সাথে যোগাযোগ করতে পারে, কিন্তু এটি সরাসরি নেটওয়ার্কের অন্য কোনো পোর্টে বা জেনেরিক সার্ভারে কানেক্ট হতে পারে না।

**উদাহরণ:**
আপনি চাইলেই জাভাস্ক্রিপ্ট দিয়ে নিচের মতো কাজ করতে পারবেন না (এটি এরর দিবে):

```javascript
// এই কোডটি ব্রাউজারে কাজ করবে না
const fs = require('fs'); // ফাইল সিস্টেম মডিউল ব্রাউজারে থাকে না
fs.unlink('/user/documents/important_file.txt', (err) => {
  if (err) throw err;
  console.log('ফাইল ডিলিট করা হয়েছে');
});

```

*ফলাফল: ব্রাউজার কনসোলে `require is not defined` বা অনুরূপ এরর দেখাবে।*

## ২. সেম-অরিজিন পলিসি (The Same-Origin Policy)

এটি ব্রাউজারের সবচেয়ে গুরুত্বপূর্ণ নিরাপত্তা নীতি। এটি নির্ধারণ করে একটি ওয়েবসাইটের স্ক্রিপ্ট অন্য ওয়েবসাইটের কন্টেন্টের সাথে যোগাযোগ করতে পারবে কি না।

### অরিজিন (Origin) কী?

একটি ডকুমেন্টের অরিজিন তিনটি জিনিসের সমন্বয়ে তৈরি হয়:

1. **প্রোটোকল** (যেমন: `http` বা `https`)
2. **হোস্ট** (যেমন: `www.example.com`)
3. **পোর্ট** (যেমন: `80`, `443`, বা `8080`)

দুটি পেজের অরিজিন "এক" (Same) হতে হলে উপরের তিনটিই হুবহু মিলতে হবে।

**অরিজিন তুলনা টেবিল:**
ধরি আমাদের বর্তমান পেজ: `http://store.company.com/dir/page.html`

| তুলনা করার URL | ফলাফল | কারণ |
   |
| `http://store.company.com/dir2/other.html` | ✅ একই অরিজিন | প্রোটোকল, হোস্ট এবং পোর্ট একই |
| `https://store.company.com/dir/page.html` | ❌ ভিন্ন | প্রোটোকল ভিন্ন (https বনাম http) |
| `http://news.company.com/dir/page.html` | ❌ ভিন্ন | হোস্ট ভিন্ন (news বনাম store) |
| `http://store.company.com:81/dir/page.html` | ❌ ভিন্ন | পোর্ট ভিন্ন (81 বনাম ডিফল্ট 80) |

### স্ক্রিপ্ট বনাম ডকুমেন্ট অরিজিন

একটি মজার বিষয় হলো, স্ক্রিপ্টটি কোথা থেকে লোড হচ্ছে তা গুরুত্বপূর্ণ নয়, স্ক্রিপ্টটি **কোথায় রান করছে** সেটাই আসল।

ধরুন, `Site A` তে একটি স্ক্রিপ্ট ট্যাগ আছে যা `Site B` (যেমন jQuery CDN বা Google Analytics) থেকে লোড করা হয়েছে। এই স্ক্রিপ্টটি `Site A` এর অরিজিনেই কাজ করবে এবং `Site A` এর সব কন্টেন্ট অ্যাক্সেস করতে পারবে।

## ৩. সেম-অরিজিন পলিসি শিথিল করার উপায়

বড় ওয়েব অ্যাপ্লিকেশনে অনেক সময় ভিন্ন সাব-ডোমেইনের মধ্যে যোগাযোগের প্রয়োজন হয়। সেক্ষেত্রে পলিসি কিছুটা শিথিল করার দুটি উপায় আছে:

### ক. `document.domain` ব্যবহার করে

যদি আপনার দুটি সাব-ডোমেইন থাকে, যেমন `orders.example.com` এবং `example.com`, তবে তারা একে অপরের সাথে যোগাযোগ করতে পারবে না। কিন্তু উভয় পেজে `document.domain` সেট করে এটি সমাধান করা যায়।

**কোড উদাহরণ:**

`https://orders.example.com` পেজের স্ক্রিপ্টে:

```javascript
// অরিজিন ছোট করে মূল ডোমেইনে আনা হলো
document.domain = "example.com";

```

`https://example.com` পেজের স্ক্রিপ্টে:

```javascript
// এখানেও একই কাজ করতে হবে
document.domain = "example.com";

```

এখন এই দুই পেজ একে অপরের `iframe` বা উইন্ডো প্রপার্টি অ্যাক্সেস করতে পারবে।

### খ. CORS (Cross-Origin Resource Sharing)

এটি সার্ভার সাইড সলিউশন। যদি আপনি `siteA.com` থেকে `siteB.com` এ একটি API রিকোয়েস্ট পাঠান, ব্রাউজার তা আটকে দিবে। কিন্তু `siteB.com` যদি রেসপন্সে বিশেষ হেডার পাঠায় তবে ব্রাউজার তা অ্যালাউ করবে।

**সার্ভার রেসপন্স হেডার:**

```http
Access-Control-Allow-Origin: https://siteA.com

```

অথবা সবার জন্য উন্মুক্ত করতে:

```http
Access-Control-Allow-Origin: *

```

## ৪. ক্রস-সাইট স্ক্রিপ্টিং (XSS)

Cross-Site Scripting বা XSS হলো এমন একটি নিরাপত্তা ত্রুটি যেখানে হ্যাকাররা একটি নিরাপদ ওয়েবসাইটে তাদের নিজস্ব ক্ষতিকর HTML বা JavaScript কোড ইনজেক্ট করে দেয়।

### কীভাবে XSS কাজ করে? (Step-by-Step)

ধরা যাক, একটি ওয়েবসাইট ইউজারর নাম URL প্যারামিটার থেকে নিয়ে সরাসরি পেজে দেখায়।

**ধাপ ১: দুর্বল কোড (Vulnerable Code)**

```html
<script>
  // URL থেকে নাম নেওয়া হচ্ছে (যেমন ?name=Karim)
  let name = new URL(document.URL).searchParams.get("name");
  // সরাসরি HTML এর ভেতর ঢুকিয়ে দেওয়া হচ্ছে (বিপদজনক!)
  document.querySelector('h1').innerHTML = "Hello " + name;
</script>

```

**ধাপ ২: স্বাভাবিক ব্যবহার**
ইউজার ভিসিট করলো: `http://example.com/greet.html?name=Rahim`
আউটপুট: **Hello Rahim**

**ধাপ ৩: হ্যাকারের আক্রমণ (Attack)**
হ্যাকার একটি লিংক তৈরি করলো যেখানে নামের বদলে জাভাস্ক্রিপ্ট কোড দেওয়া আছে:
`http://example.com/greet.html?name=<img src='x' onload='alert("Hacked!")'>`

**ধাপ ৪: এক্সিকিউশন**
যখন ভিক্টিম এই লিংকে ক্লিক করবে, ব্রাউজার `Hello` এর পরে ইমেজ ট্যাগটি রেন্ডার করবে। ইমেজের সোর্স ভুল থাকায় `onload` ইভেন্ট ফায়ার হবে এবং `alert('Hacked!')` রান করবে।
শুধু অ্যালার্ট নয়, হ্যাকার চাইলে `document.cookie` চুরি করে ইউজারের সেশন হাইজ্যাক করতে পারে।

### XSS প্রতিরোধ করার উপায় (Sanitization)

সবচেয়ে কার্যকরী উপায় হলো ইউজারের ইনপুট বিশ্বাস না করা এবং ব্যবহারের আগে তা "Sanitize" বা পরিষ্কার করা। স্পেশাল ক্যারেক্টারগুলোকে HTML Entity তে রূপান্তর করতে হবে।

**নিরাপদ কোড উদাহরণ:**

```javascript
function sanitizeInput(input) {
  return input
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")   // < হয়ে যাবে &lt; (ব্রাউজার একে ট্যাগ ভাববে না)
    .replace(/>/g, "&gt;")   // > হয়ে যাবে &gt;
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#x27;")
    .replace(/\//g, "&#x2F;");
}

let name = new URL(document.URL).searchParams.get("name");
// ইনপুট স্যানিটাইজ করা হচ্ছে
let safeName = sanitizeInput(name);

// নিরাপদ ভাবে আউটপুট দেখানো
document.querySelector('h1').innerHTML = "Hello " + safeName;

```

এখন যদি হ্যাকার স্ক্রিপ্ট দেয়, ব্রাউজার সেটাকে কোড হিসেবে রান না করে সাধারণ টেক্সট হিসেবে দেখাবে:
`Hello <img src='x' onload='alert("Hacked!")'>`

### অতিরিক্ত সুরক্ষা

* **`textContent` ব্যবহার করা:** `innerHTML` এর বদলে `textContent` ব্যবহার করলে ব্রাউজার ইনপুটকে কখনোই HTML হিসেবে পড়ে না।
* **Content Security Policy (CSP):** সার্ভার থেকে CSP হেডার পাঠিয়ে বলে দেওয়া যায় কোন সোর্স থেকে স্ক্রিপ্ট রান করা যাবে।

### সারসংক্ষেপ

১. **ক্ষমতা:** জাভাস্ক্রিপ্ট ফাইল সিস্টেম বা লো-লেভেল নেটওয়ার্ক এক্সেস করতে পারে না।

২. **অরিজিন:** প্রোটোকল, হোস্ট এবং পোর্ট মিললেই কেবল এক পেজ অন্য পেজের ডাটা দেখতে পারে।

৩. **XSS:** কখনোই ইউজারের ইনপুট সরাসরি `innerHTML` এ বসাবেন না; সবসময় স্যানিটাইজ করুন।

আগের বড় আর্টিকেলটি থেকে মনে রাখার মতো **মূল পয়েন্টগুলো (Key Points)** নিচে সংক্ষেপে দেওয়া হলো:

### ১. জাভাস্ক্রিপ্টের সীমাবদ্ধতা (What JS Can't Do)

* **ফাইল এক্সেস নেই:** জাভাস্ক্রিপ্ট আপনার কম্পিউটারের কোনো ফাইল পড়তে, লিখতে বা ডিলেট করতে পারে না।
* **নেটওয়ার্ক রেস্ট্রিকশন:** এটি চাইলেই ইন্টারনেটের যেকোনো সার্ভারে কানেক্ট হতে পারে না, শুধুমাত্র নির্দিষ্ট প্রোটোকল (HTTP/WebSockets) ছাড়া।

### ২. সেম-অরিজিন পলিসি (Same-Origin Policy)

* এটি ব্রাউজারের প্রধান নিরাপত্তা নিয়ম।
* এক পেজের স্ক্রিপ্ট অন্য পেজের ডাটা তখনই অ্যাক্সেস করতে পারবে যদি উভয়ের **প্রোটোকল** (http/https), **হোস্ট** (domain), এবং **পোর্ট** হুবহু এক হয়।

### ৩. অরিজিন পলিসি শিথিল করা

* **CORS:** সার্ভার যদি `Access-Control-Allow-Origin` হেডার পাঠায়, তবে ভিন্ন ডোমেইন থেকেও ডাটা আনা সম্ভব।
* **Subdomain:** `document.domain` ব্যবহার করে একই মেইন ডোমেইনের সাব-ডোমেইনগুলোর (যেমন: `shop.site.com` ও `blog.site.com`) মধ্যে যোগাযোগ করা যায়।

### ৪. ক্রস-সাইট স্ক্রিপ্টিং (XSS)

* এটি একটি হ্যাকিং টেকনিক যেখানে ইনপুটের মাধ্যমে ক্ষতিকর জাভাস্ক্রিপ্ট কোড ওয়েবসাইট ঢুকিয়ে দেওয়া হয়।
* এটি ঘটে যখন ওয়েবসাইট ব্যবহারকারীর ইনপুট বা ডাটা চেক না করেই (Unsanitized) সরাসরি `innerHTML` দিয়ে পেজে দেখায়।

### ৫. বাঁচার উপায় (Solution)

* কখনোই ইউজারের ইনপুট বিশ্বাস করবেন না।
* ইনপুট দেখানোর আগে স্পেশাল ক্যারেক্টার (যেমন `<, >, &, "`) গুলোকে কনভার্ট বা **Sanitize** করুন।
* টেক্সট দেখানোর জন্য `innerHTML` এর বদলে **`textContent`** বা **`innerText`** ব্যবহার করুন।
